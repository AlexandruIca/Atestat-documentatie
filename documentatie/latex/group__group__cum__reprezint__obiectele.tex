\hypertarget{group__group__cum__reprezint__obiectele}{}\section{Cum reprezint obiectele jocului?}
\label{group__group__cum__reprezint__obiectele}\index{Cum reprezint obiectele jocului?@{Cum reprezint obiectele jocului?}}
Prima data vom avea nevoie de un mod de a reprezenta omida. Cel mai usor ar fi sa folosim un vector care tine pozitii ale omizii, primul/ultimul element fiind capul omizii. Eu folosesc ceva similar dar care imi ofera mult mai multa flexibilitate si care este si mai rapid si consuma mai putina memorie, si anume std\+::deque. Deque inseamna \char`\"{}double ended queue\char`\"{} in engleza si care este un fel de coada dar care este foarte buna la insertia la inceput si la sfarsit -\/ exact ce imi trebuie. In spate deque este o lista de vectori cu o marime fixa(de exemplu 5) care vrea sa aiba avantajele unui vector de a avea memorie continua si foarte rapid de accesat dar si avantajele unei liste de a fi foarte eficienta la insertia in mijlocul unui sir.

Omida este stocata in variabila \hyperlink{classStadiulJocului_a64e0608d9c68b22ea83fd5aba209453f}{Stadiul\+Jocului\+::pozitii\+\_\+omida}. Tipul de date folosit pentru a stoca efectiv pozitiil este \hyperlink{structPunct}{Punct}. De remarcat este faptul ca retin pozitiile unei matrici(care reprezinta terenul) \hyperlink{classStadiulJocului_a2e71823589e83f16593f8a2870c065e6}{Stadiul\+Jocului\+::teren}, nu valorile absolute in fereastra. Acest lucru face mult mai usoara logica jocului.

Cand jocul incepe sunt inserate 3 pozitii in omida. Cand este timpul ca pozitia omizii sa fie actualizata chem \hyperlink{classJoc_afd69d2cd19f6d2ac2b1a42a4685349e6}{Joc\+::muta\+\_\+omida}. La fiecare pas chem \hyperlink{main_8cpp_aa57c630272aa6ab8ab15552adf8c165e}{deseneaza\+\_\+omida}, care parcurge \hyperlink{classStadiulJocului_a64e0608d9c68b22ea83fd5aba209453f}{Stadiul\+Jocului\+::pozitii\+\_\+omida} si deseneaza fiecare parte a omizii pe ecran.

Pentru a usura munca de a schimba directia omizii folosescu o enumeratie \hyperlink{main_8cpp_aea66a0d525bf9bfb9b61e9cc1ba0b752}{Tip\+Directie}. Apoi am un vector \hyperlink{main_8cpp_a68e903f0d20f0a68b3c01b73eb34e9ed}{directie} care va tine valorile cu care trebuie sa incrementez i-\/ul si j-\/ul omizii pentru a se deplasa. Cand omida se deplaseaza inserez la inceputul cozii noua pozitie a capului in functie de directie. Daca nu a mancat nimic cat s-\/a deplasat atunci sterg ultima pozitie din coada.

Pozitia frunzei este retinuta in variabila \hyperlink{classStadiulJocului_a141067404f3678036ee7a91a02532a30}{Stadiul\+Jocului\+::pozitie\+\_\+frunza}. Cand omida mananca o frunza trebuie generata o noua pozitie, astfel chem functia \hyperlink{main_8cpp_a5f6f5f86af147286478cc7aadd76b0a2}{genereaza\+\_\+pozitie\+\_\+noua}. Aceeasi functie este chemata si atunci cand omida mananca un mar.

Daca jucatorul apasa tasta escape atunci chem functia \hyperlink{classJoc_a0f90008558e8cbed6537b542f79ae55b}{Joc\+::pauza}. 